import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { createClient } from '@supabase/supabase-js';

// Inizializza Supabase client
function getSupabaseClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY;

  console.log('[DEPLOY] [SUPABASE] URL:', supabaseUrl ? 'trovato' : 'MANCANTE');
  console.log('[DEPLOY] [SUPABASE] KEY:', supabaseKey ? 'trovato' : 'MANCANTE');

  if (!supabaseUrl || !supabaseKey) {
    throw new Error('Supabase credentials non configurate');
  }

  return createClient(supabaseUrl, supabaseKey);
}

// Inizializza GitHub client
function getGitHubClient() {
  const githubToken = process.env.GITHUB_TOKEN;
  
  console.log('[DEPLOY] [GITHUB] TOKEN:', githubToken ? 'trovato' : 'MANCANTE');
  
  if (!githubToken) {
    throw new Error('GITHUB_TOKEN non configurato');
  }

  return new Octokit({
    auth: githubToken,
  });
}

// Crea file base necessari per Next.js
function getBaseFiles() {
  return {
    'package.json': JSON.stringify({
      name: 'erp-generated-app',
      version: '0.1.0',
      private: true,
      scripts: {
        dev: 'next dev',
        build: 'next build',
        start: 'next start',
        lint: 'eslint',
      },
      dependencies: {
        next: '16.1.1',
        react: '19.2.3',
        'react-dom': '19.2.3',
        '@supabase/supabase-js': '^2.89.0',
        'framer-motion': '^12.23.26',
      },
      devDependencies: {
        '@tailwindcss/postcss': '^4',
        '@types/node': '^20',
        '@types/react': '^19',
        '@types/react-dom': '^19',
        'eslint': '^9',
        'eslint-config-next': '16.1.1',
        'tailwindcss': '^4',
        'typescript': '^5',
      },
    }, null, 2),
    'tsconfig.json': JSON.stringify({
      compilerOptions: {
        target: 'ES2017',
        lib: ['dom', 'dom.iterable', 'esnext'],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        noEmit: true,
        esModuleInterop: true,
        module: 'esnext',
        moduleResolution: 'bundler',
        resolveJsonModule: true,
        isolatedModules: true,
        jsx: 'react-jsx',
        incremental: true,
        plugins: [{ name: 'next' }],
        paths: {
          '@/*': ['./*'],
        },
      },
      include: ['next-env.d.ts', '**/*.ts', '**/*.tsx', '.next/types/**/*.ts'],
      exclude: ['node_modules'],
    }, null, 2),
    'next.config.ts': `import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;`,
    'tailwind.config.ts': `import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;`,
    'postcss.config.mjs': `/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;`,
    '.gitignore': `# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files
.env*
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts`,
    'README.md': `# ERP Generated App

This application was generated using ERP Builder AI.

## Getting Started

\`\`\`bash
npm install
npm run dev
\`\`\`

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.`,
    'app/globals.css': `@tailwind base;
@tailwind components;
@tailwind utilities;`,
    'app/layout.tsx': `import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "ERP Generated App",
  description: "Generated by ERP Builder AI",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="it">
      <body
        className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
      >
        {children}
      </body>
    </html>
  );
}`,
  };
}


export async function POST(request: NextRequest) {
  try {
    console.log('[DEPLOY] Inizio richiesta deploy');
    
    // Leggi appId dal body
    console.log('[DEPLOY] Lettura body richiesta...');
    const body = await request.json();
    const { appId } = body;
    
    if (!appId || typeof appId !== 'string') {
      console.error('[DEPLOY] appId non valido');
      return NextResponse.json(
        { success: false, error: 'appId richiesto' },
        { status: 400 }
      );
    }
    console.log('[DEPLOY] appId ricevuto:', appId);

    // Leggi app da Supabase
    console.log('[DEPLOY] Lettura app da Supabase...');
    const supabase = getSupabaseClient();
    
    const { data: appData, error: supabaseError } = await supabase
      .from('generated_apps')
      .select('*')
      .eq('id', appId)
      .single();

    if (supabaseError || !appData) {
      console.error('[DEPLOY] Errore lettura Supabase:', supabaseError);
      return NextResponse.json(
        { success: false, error: `App non trovata: ${supabaseError?.message || 'App non esistente'}` },
        { status: 404 }
      );
    }
    console.log('[DEPLOY] App letta da Supabase, file count:', Object.keys(appData.files || {}).length);

    if (!appData.files || Object.keys(appData.files).length === 0) {
      console.error('[DEPLOY] Nessun file trovato nell\'app');
      return NextResponse.json(
        { success: false, error: 'Nessun file trovato nell\'app' },
        { status: 400 }
      );
    }

    // Inizializza GitHub client
    console.log('[DEPLOY] Inizializzazione GitHub client...');
    const octokit = getGitHubClient();
    console.log('[DEPLOY] GitHub client inizializzato');

    // Genera nome repo
    const repoName = `erp-demo-${appId.substring(0, 6)}`;
    console.log('[DEPLOY] Nome repo:', repoName);

    // Ottieni username GitHub
    console.log('[DEPLOY] Ottenimento username GitHub...');
    const { data: userData } = await octokit.users.getAuthenticated();
    const username = userData.login;
    console.log('[DEPLOY] Username GitHub:', username);

    // Crea repository GitHub
    console.log('[DEPLOY] Creazione repository GitHub...');
    let repo;
    try {
      const createRepoResponse = await octokit.repos.createForAuthenticatedUser({
        name: repoName,
        private: true,
        auto_init: true,
        description: `ERP app generata: ${appData.prompt?.substring(0, 100) || 'Generated app'}`,
      });
      repo = createRepoResponse.data;
      console.log('[DEPLOY] Repository creata:', repo.html_url);
    } catch (error: any) {
      if (error.status === 422 && (error.message?.includes('already exists') || error.message?.includes('name already exists'))) {
        console.log('[DEPLOY] Repository già esistente, uso quella esistente');
        // Prova a ottenere il repo esistente
        const { data: existingRepo } = await octokit.repos.get({
          owner: username,
          repo: repoName,
        });
        repo = existingRepo;
        console.log('[DEPLOY] Repository esistente recuperata:', repo.html_url);
      } else {
        throw error;
      }
    }

    // Prepara tutti i file (base + generati)
    console.log('[DEPLOY] Preparazione file...');
    const baseFiles = getBaseFiles();
    const allFiles = { ...baseFiles, ...appData.files };
    console.log('[DEPLOY] File totali da pushare:', Object.keys(allFiles).length);

    // Ottieni SHA del branch main/master
    console.log('[DEPLOY] Ottenimento SHA branch...');
    let branchSha: string;
    try {
      const { data: refData } = await octokit.git.getRef({
        owner: repo.owner.login,
        repo: repo.name,
        ref: 'heads/main',
      });
      branchSha = refData.object.sha;
      console.log('[DEPLOY] SHA branch main:', branchSha);
    } catch (error: any) {
      // Prova master se main non esiste
      try {
        const { data: refData } = await octokit.git.getRef({
          owner: repo.owner.login,
          repo: repo.name,
          ref: 'heads/master',
        });
        branchSha = refData.object.sha;
        console.log('[DEPLOY] SHA branch master:', branchSha);
      } catch (e) {
        console.error('[DEPLOY] Errore ottenimento branch:', e);
        throw new Error('Impossibile ottenere SHA del branch');
      }
    }

    // Ottieni tree del commit corrente
    console.log('[DEPLOY] Ottenimento tree commit corrente...');
    const { data: commitData } = await octokit.git.getCommit({
      owner: repo.owner.login,
      repo: repo.name,
      commit_sha: branchSha,
    });
    const baseTreeSha = commitData.tree.sha;
    console.log('[DEPLOY] Base tree SHA:', baseTreeSha);

    // Crea blobs per ogni file
    console.log('[DEPLOY] Creazione blobs GitHub...');
    const blobShas: Record<string, string> = {};
    for (const [path, content] of Object.entries(allFiles)) {
      const { data: blobData } = await octokit.git.createBlob({
        owner: repo.owner.login,
        repo: repo.name,
        content: Buffer.from(content).toString('base64'),
        encoding: 'base64',
      });
      blobShas[path] = blobData.sha;
    }
    console.log('[DEPLOY] Blobs creati:', Object.keys(blobShas).length);

    // Crea tree con tutti i file
    console.log('[DEPLOY] Creazione tree con file...');
    const treeItemsWithSha = Object.entries(allFiles).map(([path, _]) => ({
      path,
      mode: '100644' as const,
      type: 'blob' as const,
      sha: blobShas[path],
    }));

    const { data: treeData } = await octokit.git.createTree({
      owner: repo.owner.login,
      repo: repo.name,
      base_tree: baseTreeSha,
      tree: treeItemsWithSha,
    });
    console.log('[DEPLOY] Tree creato:', treeData.sha);

    // Crea commit
    console.log('[DEPLOY] Creazione commit...');
    const { data: commitResponse } = await octokit.git.createCommit({
      owner: repo.owner.login,
      repo: repo.name,
      message: 'Initial commit: Generated ERP app',
      tree: treeData.sha,
      parents: [branchSha],
    });
    console.log('[DEPLOY] Commit creato:', commitResponse.sha);

    // Aggiorna reference
    console.log('[DEPLOY] Aggiornamento reference...');
    const branchName = repo.default_branch || 'main';
    await octokit.git.updateRef({
      owner: repo.owner.login,
      repo: repo.name,
      ref: `heads/${branchName}`,
      sha: commitResponse.sha,
    });
    console.log('[DEPLOY] Reference aggiornata');

    // Costruisci URL
    const repoUrl = repo.html_url;
    const deployUrl = `https://${repoName}.vercel.app`; // Vercel auto-deploya da GitHub

    console.log('[DEPLOY] Deploy completato!');
    console.log('[DEPLOY] Repo URL:', repoUrl);
    console.log('[DEPLOY] Deploy URL:', deployUrl);

    // Salva deployUrl nel database
    const supabase = getSupabaseClient();
    try {
      const { error: updateError } = await supabase
        .from('generated_apps')
        .update({ deployUrl: deployUrl })
        .eq('id', appId);
      
      if (updateError) {
        console.warn('[DEPLOY] Impossibile salvare deployUrl:', updateError);
        // Non blocchiamo se il deployUrl non può essere salvato (colonna potrebbe non esistere)
      } else {
        console.log('[DEPLOY] deployUrl salvato nel database');
      }
    } catch (error) {
      console.warn('[DEPLOY] Errore durante salvataggio deployUrl:', error);
      // Non blocchiamo se c'è un errore
    }

    return NextResponse.json({
      success: true,
      repoUrl,
      deployUrl,
      message: 'Deploy completato con successo!',
    });
  } catch (error) {
    console.error('[DEPLOY] Errore durante il deploy:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Errore sconosciuto durante il deploy',
      },
      { status: 500 }
    );
  }
}

